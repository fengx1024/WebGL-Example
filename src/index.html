<html>
    <head>
        <link rel="stylesheet" href="style.css" />
        <script id="vertex-shader" type="x-shader/x-vertex">
            #version 300 es

            precision highp float;

            in vec3 a_position;
            in vec3 a_normal;
            in vec2 a_uv;
            in vec4 a_vertex_color;

            out vec3 v_normal;
            out vec2 v_uv;
            out vec4 v_vertex_color;
            out vec3 v_pos;
            out vec3 v_camera_position;

            uniform mat4 u_projection;
            uniform mat4 u_view;
            uniform mat4 u_model;

            void main() {
                vec4 world_position = u_model * vec4(a_position, 1);
                vec4 view_position = u_view * world_position;
                v_camera_position = (inverse(u_view) * vec4(0, 0, 0, 1)).xyz;
                v_pos = world_position.xyz;
                gl_Position = u_projection * view_position;
                v_normal = mat3(u_model) * a_normal;
                v_uv = a_uv;
                v_vertex_color = a_vertex_color;
            }
        </script>
        <script id="fragment-shader" type="x-shader/x-fragment">
            #version 300 es

            precision highp float;

            in vec3 v_normal;
            in vec2 v_uv;
            in vec4 v_vertex_color;
            in vec3 v_pos;
            in vec3 v_camera_position;

            out vec4 g_color;

            uniform bool u_has_vertex_color;

            uniform vec4 u_color;
            uniform bool u_has_texture;
            uniform sampler2D u_texture;
            uniform vec3 u_lighting_position;
            uniform float u_specular_amount;
            uniform vec3 u_light_color;
            uniform vec3 u_ambient_color;

            void main() {
                // normalize(vec3): vec3
                // dot(vec3, vec3): float
                // length(vec3): float
                // reflect(vec3, vec3): vec3
                // pow(float, float): float
                vec4 color = u_color;
                if (u_has_vertex_color) {
                    color *= v_vertex_color;
                }
                if (u_has_texture) {
                    color *= texture(u_texture, v_uv);
                }
                vec3 normal = normalize(v_normal);
                vec3 light_direction = u_lighting_position - v_pos;
                vec3 normalized_light_direction = normalize(light_direction);
                vec3 view_direction = v_camera_position - v_pos;
                vec3 normalized_view_direction = normalize(view_direction);
                vec3 reflect_direction = reflect(-normalized_light_direction, normal);

                float diffuse = max(0.0, dot(normal, normalized_light_direction));
                float specular = pow(max(0.0, dot(reflect_direction, normalized_view_direction)), u_specular_amount);
                g_color = vec4((u_ambient_color + (diffuse + specular) * u_light_color) * color.rgb, 1.0);
                // g_color = vec4(v_normal, 1.0);
            }
        </script>
        <script src="https://flyover.github.io/imgui-js/dist/imgui.umd.js"></script>
        <script src="https://flyover.github.io/imgui-js/dist/imgui_impl.umd.js"></script>
    </head>

    <body>
        <canvas id="canvas" style="width: 100%; height: 100%"></canvas>
        <div style="position: absolute; left: 0; top: 0">
            <select id="model-selection"></select>
        </div>
        <script type="module">
            import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
            import { vec3, quat, mat3, mat4 } from 'https://unpkg.com/gl-matrix@3.1.0/esm/index.js';
            import { createProgram, gltfBufferToArray, newGltfLoader } from './helper.js';

            const canvas = document.getElementById('canvas');
            /**
             * @type {WebGL2RenderingContext}
             */
            const gl = canvas.getContext('webgl2', { alpha: false });

            const program = createProgram(gl, 'vertex-shader', 'fragment-shader');
            const projectionUniform = gl.getUniformLocation(program, 'u_projection');
            const viewUniform = gl.getUniformLocation(program, 'u_view');
            const modelUniform = gl.getUniformLocation(program, 'u_model');
            const colorUniform = gl.getUniformLocation(program, 'u_color');
            const hasVertexColorUniform = gl.getUniformLocation(program, 'u_has_vertex_color');
            const hasTextureUniform = gl.getUniformLocation(program, 'u_has_texture');
            const textureUniform = gl.getUniformLocation(program, 'u_texture');
            const lightingPositionUniform = gl.getUniformLocation(program, 'u_lighting_position');
            const specularAmountUniform = gl.getUniformLocation(program, 'u_specular_amount');
            const lightcolorUniform = gl.getUniformLocation(program, 'u_light_color');
            const ambientcolorUniform = gl.getUniformLocation(program, 'u_ambient_color');
            // TODO: get light uniform locations.
            gl.useProgram(program);

            class Geometry {
                constructor(gltfGeometry) {
                    // One vertex array for one geometry.
                    const vertexArray = gl.createVertexArray();
                    gl.bindVertexArray(vertexArray);

                    const positionLocation = Geometry.fillFloatVertexArray('a_position', gltfBufferToArray(gltfGeometry.attributes.position), 3);
                    const normalLocation = Geometry.fillFloatVertexArray('a_normal', gltfBufferToArray(gltfGeometry.attributes.normal), 3);
                    const uvLocation = Geometry.fillFloatVertexArray('a_uv', gltfBufferToArray(gltfGeometry.attributes.uv), 2);
                    const colorLocation = Geometry.fillFloatVertexArray('a_vertex_color', gltfBufferToArray(gltfGeometry.attributes.color), 4);

                    // Indices.
                    const indexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                    const indices = gltfBufferToArray(gltfGeometry.index);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                    console.log('index array', indices);

                    this.vertexArray = vertexArray;
                    this.indexCount = indices.length;
                    this.positionLocation = positionLocation;
                    this.normalLocation = normalLocation;
                    this.uvLocation = uvLocation;
                    this.colorLocation = colorLocation;
                }

                static fillFloatVertexArray(name, data, itemSize) {
                    if (!data) {
                        return -1;
                    }
                    console.log('array', name, data);
                    const buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
                    const location = gl.getAttribLocation(program, name);
                    gl.vertexAttribPointer(location, itemSize, gl.FLOAT, false, 0, 0);
                    return location;
                }

                static fillIntVertexArray(name, data, itemSize) {
                    const location = gl.getAttribLocation(program, name);
                    gl.vertexAttribI4i(location, 0, 0, 0, 0);
                    if (!data) {
                        return -1;
                    }
                    const buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Int32Array(data), gl.STATIC_DRAW);
                    gl.vertexAttribIPointer(location, itemSize, gl.INT, 0, 0);
                    return location;
                }

                render() {
                    gl.bindVertexArray(this.vertexArray);
                    gl.enableVertexAttribArray(this.positionLocation);
                    gl.enableVertexAttribArray(this.normalLocation);
                    if (this.uvLocation !== -1) {
                        gl.enableVertexAttribArray(this.uvLocation);
                    }
                    if (this.colorLocation !== -1) {
                        gl.enableVertexAttribArray(this.colorLocation);
                        gl.uniform1i(hasVertexColorUniform, 1);
                    } else {
                        gl.uniform1i(hasVertexColorUniform, 0);
                    }
                    gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
                }
            }

            class Texture {
                constructor(gltfTexture) {
                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gltfTexture.image);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                    this.texture = texture;
                }
            }

            class Material {
                constructor(gltfMaterial) {
                    const c = gltfMaterial.color;
                    this.color = [c.r, c.g, c.b, 1];
                    this.texture = gltfMaterial.map ? new Texture(gltfMaterial.map) : null;
                    this.transparent = gltfMaterial.transparent;
                    this.alphaTest = gltfMaterial.alphaTest;
                }

                apply() {
                    gl.uniform4fv(colorUniform, this.color);
                    gl.activeTexture(gl.TEXTURE0);
                    if (this.texture) {
                        gl.bindTexture(gl.TEXTURE_2D, this.texture.texture);
                        gl.uniform1i(hasTextureUniform, 1);
                    } else {
                        gl.uniform1i(hasTextureUniform, 0);
                    }
                    gl.uniform1i(textureUniform, 0);
                }
            }

            class Node {
                constructor(parent) {
                    this.parent = parent;
                    this.children = [];
                    this.position = [0, 0, 0];
                    this.rotation = [0, 0, 0, 1];
                    this.scale = [1, 1, 1];
                    this.localMatrix = mat4.create();
                    this.worldMatrix = mat4.create();
                    if (parent) {
                        parent.children.push(this);
                    }
                }

                render() {
                    if (this.gltfObject) {
                        vec3.set(this.position, this.gltfObject.position.x, this.gltfObject.position.y, this.gltfObject.position.z);
                        quat.set(
                            this.rotation,
                            this.gltfObject.quaternion.x,
                            this.gltfObject.quaternion.y,
                            this.gltfObject.quaternion.z,
                            this.gltfObject.quaternion.w
                        );
                        vec3.set(this.scale, this.gltfObject.scale.x, this.gltfObject.scale.y, this.gltfObject.scale.z);
                    }

                    mat4.fromRotationTranslationScale(this.localMatrix, this.rotation, this.position, this.scale);
                    if (this.parent) {
                        mat4.multiply(this.worldMatrix, this.parent.worldMatrix, this.localMatrix);
                    } else {
                        mat4.copy(this.worldMatrix, this.localMatrix);
                    }

                    for (let child of this.children) {
                        child.render();
                    }
                }
            }

            class Mesh extends Node {
                constructor(parent, geometry, material) {
                    super(parent);
                    this.geometry = geometry;
                    this.material = material;
                }

                render() {
                    super.render();
                    gl.useProgram(program);
                    gl.uniformMatrix4fv(modelUniform, false, this.worldMatrix);
                    this.material.apply();
                    this.geometry.render();
                }
            }

            const zNear = 0.1;
            const zFar = 100;
            const projection = mat4.perspective(mat4.create(), Math.PI / 3, 1, zNear, zFar);
            let cameraPitch = 0;
            let cameraYaw = 0;
            let cameraDistance = 3;
            function updateViewMatrix(view) {
                mat4.identity(view);
                mat4.rotateY(view, view, cameraYaw);
                mat4.rotateX(view, view, cameraPitch);
                mat4.translate(view, view, [0, 0, cameraDistance]);
                mat4.invert(view, view);
                return view;
            }
            const view = updateViewMatrix(mat4.create());
            function getOrSetCameraPitch(value) {
                if (value == null) {
                    return cameraPitch;
                }
                cameraPitch = value;
                updateViewMatrix(view);
                return cameraPitch;
            }
            function getOrSetCameraYaw(value) {
                if (value == null) {
                    return cameraYaw;
                }
                cameraYaw = value;
                updateViewMatrix(view);
                return cameraYaw;
            }

            gl.uniformMatrix4fv(projectionUniform, false, projection);
            gl.uniformMatrix4fv(viewUniform, false, view);

            let root = new Node();

            const lightPosition = [0, 10, 0];
            const lightDirection = [0, -1, 0];
            const lightColor = [1, 1, 1];
            const ambientColor = [0.25, 0.25, 0.25];
            let specularAmount = 32;
            function getOrSetSpecularAmount(value) {
                if (value == null) {
                    return specularAmount;
                }
                specularAmount = value;
                return specularAmount;
            }

            let lastAspectRatio = 1;
            function render(time) {
                if (gl.canvas.width != gl.canvas.clientWidth || gl.canvas.height != gl.canvas.clientHeight) {
                    const w = (gl.canvas.width = gl.canvas.clientWidth);
                    const h = (gl.canvas.height = gl.canvas.clientHeight);
                    gl.viewport(0, 0, w, h);
                }
                let currentAspectRatio = gl.canvas.width / gl.canvas.height;
                if (currentAspectRatio !== lastAspectRatio) {
                    lastAspectRatio = currentAspectRatio;
                    mat4.perspective(projection, Math.PI / 3, lastAspectRatio, zNear, zFar);
                    gl.uniformMatrix4fv(projectionUniform, false, projection);
                }

                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                gl.enable(gl.DEPTH_TEST);

                gl.useProgram(program);
                gl.uniformMatrix4fv(viewUniform, false, view);

                // TODO: Set light uniforms.
                gl.uniform3fv(lightingPositionUniform, lightPosition);

                gl.uniform1f(specularAmountUniform, specularAmount);
                gl.uniform3fv(lightcolorUniform, lightColor);
                gl.uniform3fv(ambientcolorUniform, ambientColor);

                root.render();

                // UI
                ImGui_Impl.NewFrame(time);
                ImGui.NewFrame();
                ImGui.SetNextWindowPos(new ImGui.ImVec2(4, 24), ImGui.Always);
                ImGui.Begin('Default', null, ImGui.WindowFlags.NoTitleBar | ImGui.WindowFlags.NoResize | ImGui.WindowFlags.AlwaysAutoResize);
                if (ImGui.Button('Reset')) {
                    cameraPitch = 0;
                    cameraYaw = 0;
                    updateViewMatrix(view);
                    vec3.set(root.position, 0, 0, 0);
                    vec3.set(root.scale, 1, 1, 1);
                    vec3.set(lightPosition, 0, 10, 0);
                    vec3.set(lightDirection, 0, -1, 0);
                    vec3.set(lightColor, 1, 1, 1);
                    vec3.set(ambientColor, 0.25, 0.25, 0.25);
                }
                ImGui.Text('Camera');
                ImGui.SliderFloat('pitch##camera', getOrSetCameraPitch, -Math.PI / 2, Math.PI / 2);
                ImGui.SliderFloat('yaw##camera', getOrSetCameraYaw, -Math.PI, Math.PI);
                ImGui.Text('Model');
                ImGui.DragFloat3('position##model', root.position, 0.01);
                ImGui.DragFloat3('scale##model', root.scale, 0.01);
                ImGui.Text('Light');
                ImGui.DragFloat3('position##light', lightPosition, 0.1);
                ImGui.DragFloat3('direction##light', lightDirection, 0.1);
                ImGui.ColorEdit3('light color##light', lightColor);
                ImGui.ColorEdit3('ambient color##light', ambientColor);
                ImGui.SliderFloat('specular amount##light', getOrSetSpecularAmount, 0, 128);
                ImGui.End();
                ImGui.EndFrame();
                ImGui.Render();
                ImGui_Impl.RenderDrawData(ImGui.GetDrawData());

                window.requestAnimationFrame(render);
            }
            async function startImGui() {
                await ImGui.default();
                ImGui.CreateContext();
                ImGui_Impl.Init(canvas);
                window.requestAnimationFrame(render);
            }
            startImGui();

            let mouseDown = false;
            let mouseStartX = 0;
            let mouseStartY = 0;
            let mouseButton = 0;
            document.addEventListener('mousedown', (e) => {
                if (ImGui.GetIO().WantCaptureMouse) {
                    return;
                }
                mouseDown = true;
                mouseStartX = e.x;
                mouseStartY = e.y;
                mouseButton = e.button;
            });
            document.addEventListener('mousemove', (e) => {
                if (mouseDown) {
                    const offsetX = e.x - mouseStartX;
                    const offsetY = e.y - mouseStartY;
                    if (mouseButton === 0) {
                        cameraYaw -= (offsetX / 512) * Math.PI;
                        cameraPitch -= (offsetY / 512) * Math.PI;
                        cameraPitch = Math.min(cameraPitch, Math.PI / 2);
                        cameraPitch = Math.max(cameraPitch, -Math.PI / 2);
                        updateViewMatrix(view);
                        gl.uniformMatrix4fv(viewUniform, false, view);
                    } else {
                        const viewTranslation = [offsetX / 512, -offsetY / 512, 0];
                        const worldToView = mat4.getRotation(quat.create(), view);
                        const viewToWorld = quat.invert(quat.create(), worldToView);
                        const worldTranslation = vec3.transformQuat(vec3.create(), viewTranslation, viewToWorld);
                        vec3.add(root.position, root.position, worldTranslation);
                    }
                    mouseStartX = e.x;
                    mouseStartY = e.y;
                }
            });
            document.addEventListener('mouseup', (e) => {
                mouseDown = false;
            });
            document.addEventListener('wheel', (e) => {
                if (ImGui.GetIO().WantCaptureMouse) {
                    return;
                }
                const scale = 1 - event.deltaY / 1000;
                vec3.multiply(root.scale, root.scale, [scale, scale, scale]);
            });
            document.addEventListener('contextmenu', (event) => event.preventDefault());

            class GltfModelBuilder {
                constructor(gltf) {
                    this.gltf = gltf;
                }

                build() {
                    const root = new Node();
                    this._build(root, this.gltf.scene);
                    return root;
                }

                _build(parent, gltfObject) {
                    if (gltfObject instanceof THREE.Mesh) {
                        const geometry = new Geometry(gltfObject.geometry);
                        const material = new Material(gltfObject.material);
                        const mesh = new Mesh(parent, geometry, material);
                        mesh.position = gltfObject.position.toArray();
                        mesh.rotation = gltfObject.quaternion.toArray();
                        mesh.scale = gltfObject.scale.toArray();
                        mesh.gltfObject = gltfObject;
                        gltfObject.mynode = mesh;
                        return mesh;
                    }
                    const node = new Node(parent);
                    node.position = gltfObject.position.toArray();
                    node.rotation = gltfObject.quaternion.toArray();
                    node.scale = gltfObject.scale.toArray();
                    node.gltfObject = gltfObject;
                    for (let child of gltfObject.children) {
                        this._build(node, child);
                    }
                    gltfObject.mynode = node;
                    return node;
                }
            }

            const models = [
                'examples/Box/glTF/Box.gltf',
                'examples/BoxVertexColors/glTF/BoxVertexColors.gltf',
                'examples/BoxTextured/glTF/BoxTextured.gltf',
                'https://github.khronos.org/glTF-Sample-Viewer-Release/assets/models/2.0/Duck/glTF/Duck.gltf',
                ['examples/One Piece Marine Ship/gltf.gltf', 0.01],
            ];

            let index = 0;
            function loadModel() {
                const name = Array.isArray(models[index]) ? models[index][0] : models[index];
                const scale = Array.isArray(models[index]) ? models[index][1] : 1;
                newGltfLoader().load(name, (gltf) => {
                    root = new GltfModelBuilder(gltf).build();
                    vec3.multiply(root.scale, root.scale, [scale, scale, scale]);
                });
            }

            loadModel();

            const select = document.getElementById('model-selection');
            for (let i = 0; i < models.length; i++) {
                const option = document.createElement('option');
                option.setAttribute('value', i);
                option.innerText = models[i];
                select.appendChild(option);
            }
            select.addEventListener('change', (e) => {
                index = parseInt(e.target.value);
                loadModel();
            });
        </script>
    </body>
</html>
